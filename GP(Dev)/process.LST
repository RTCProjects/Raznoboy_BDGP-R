C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 1   


C166 COMPILER V7.53.0.0, COMPILATION OF MODULE PROCESS
OBJECT MODULE PLACED IN .\firmwares\process.obj
COMPILER INVOKED BY: C:\Keil\C166\BIN\C166.EXE process.c BROWSE MOD167 DEBUG TABS(2) OBJECT(.\firmwares\process.obj) 

 stmt lvl     source

    1         #include "process.h"
    2         #include "protocol.h"
    3         #include "settings.h"
    4         #include "can.h"
    5         #include "debug.h"
    6         
    7         const uint16  tempSensorData_1[] = {29,22,31,1,0,0,2,1,0,2,18,20};
    8         
    9         uint8   firstMeasureCounter = 0;
   10         uint8   sliderCounter = 0;
   11         uint8   sliderMode = 0;
   12         uint16  sensorCnt[SENSORS];
   13         uint16  sensorCntCopy[SENSORS];
   14         
   15         float   sliderQuery[SLIDER_SIZE];
   16         
   17         eAutoModeState  autoMode;
   18         eExternalRange  extRange;
   19         
   20         void  Process_SetAutoMode(eAutoModeState State){autoMode = State;}
   21         uint8 Process_GetAutoModeStatus(){return autoMode;}
   22         void  Process_SetExternalRange(eExternalRange ExtRange){extRange = ExtRange;}
   23         uint8 Process_GetExternalRange(){return extRange;}
   24         
   25         void  Process_Initializetion(void)
   26         {
   27  1        CC8IC = 0x0070;
   28  1        CC9IC = 0x0071;
   29  1        CC10IC = 0x0072;
   30  1        CC11IC = 0x0073;
   31  1        CC12IC = 0x0074;
   32  1        CC13IC = 0x0075;
   33  1        CC14IC = 0x0076;
   34  1        CC15IC = 0x0077;
   35  1        
   36  1        T2IC = 0x0078;
   37  1        T3IC = 0x0079;
   38  1        T4IC = 0x007A;
   39  1        T5IC = 0x007B;
   40  1        memset(sensorCnt,0,sizeof(uint16) * SENSORS);
   41  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);
   42  1        
   43  1        memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
   44  1        
   45  1        autoMode = AUTO_OFF;
   46  1        extRange = EXT_OFF;
   47  1        
   48  1        sliderMode = 0;
   49  1      }
   50         
   51         /*
   52           –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–º–ø—É–ª—å—Å–∞ —Å—á—ë—Ç—á–∏–∫–∞
   53           1. –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä—É–µ–º —Å—á—ë—Ç—á–∏–∫ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–Ω–∞–ª–∞
   54           2. –°–Ω–∏–º–∞–µ–º –ø–∏—Ç–∞–Ω–∏–µ  –Ω–∞ —Å—á—ë—Ç—á–∏–∫–∞—Ö –Ω–∞ 100us
   55         */
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 2   

   56         
   57         void Process_EXIN1()  interrupt CC8IC_VEC
   58         {
   59  1        
   60  1        T7 = 0xFFFF;
   61  1        sensorCntCopy[0]++;
   62  1      }
   63         void Process_EXIN2()  interrupt CC9IC_VEC
   64         {
   65  1        T7 = 0xFFFF;
   66  1        sensorCntCopy[1]++;
   67  1        
   68  1      }
   69         void Process_EXIN3()  interrupt CC10IC_VEC
   70         {
   71  1        T7 = 0xFFFF;
   72  1        sensorCntCopy[2]++;
   73  1      }
   74         void Process_EXIN4()  interrupt CC11IC_VEC
   75         {
   76  1        T7 = 0xFFFF;
   77  1        sensorCntCopy[3]++;
   78  1      }
   79         void Process_EXIN5()  interrupt CC12IC_VEC
   80         {
   81  1        T7 = 0xFFFF;
   82  1        sensorCntCopy[4]++;
   83  1      }
   84         void Process_EXIN6()  interrupt CC13IC_VEC
   85         {
   86  1        T7 = 0xFFFF;
   87  1        sensorCntCopy[5]++;
   88  1      }
   89         void Process_EXIN7()  interrupt CC14IC_VEC
   90         {
   91  1        T8 = 0xFFFF;
   92  1        sensorCntCopy[6]++;
   93  1      }
   94         void Process_EXIN8()  interrupt CC15IC_VEC
   95         {
   96  1        T8 = 0xFFFF;
   97  1        sensorCntCopy[7]++;
   98  1      }
   99         void Process_EXIN9()  interrupt T5IC_VEC
  100         {
  101  1        T8 = 0xFFFF;
  102  1        
  103  1        sensorCntCopy[8]++;
  104  1      }
  105         void Process_EXIN10() interrupt T4IC_VEC
  106         {
  107  1        T8 = 0xFFFF;
  108  1        
  109  1        sensorCntCopy[9]++;
  110  1      }
  111         void Process_EXIN11() interrupt T3IC_VEC
  112         {
  113  1        T8 = 0xFFFF;
  114  1        
  115  1        sensorCntCopy[10]++;
  116  1      }
  117         void Process_EXIN12() interrupt T2IC_VEC
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 3   

  118         {
  119  1        T8 = 0xFFFF;
  120  1        
  121  1        sensorCntCopy[11]++;
  122  1      }
  123         
  124         void  Process_MainProc()  interrupt T0IC_VEC
  125         {
  126  1         uint8  *pSendPackage;
  127  1        
  128  1         uint8  mStartRangeAuto1[]  = {0x01,0x01,0x01};
  129  1         uint8  mStartRangeAuto2[]  = {0x02,0x01,0x01};
  130  1         uint8  mStartRangeAuto3[]  = {0x03,0x01,0x01};
  131  1      /*  float currentDose = 0;
  132  1        
  133  1        currentDose = Process_CalculateDoseRate();
  134  1        
  135  1        
  136  1        Protocol_HeaderDataMsg();
  137  1        Protocol_CounterMsg(sensorCnt);
  138  1        Protocol_DoseRateMsg(currentDose);
  139  1        */
  140  1        //Protocol_ResponseDataPackaje(E_NEWDATA_RESPONSE);
  141  1        uint8 i = 0,j = 0;
  142  1        
  143  1        uint16  rangeMin = (uint16)(MainSettings.rangeLimits & 0xFFFF);
  144  1        uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  145  1        uint16  rangeMinExt = (uint16)(MainSettingsExt.rangeLimits & 0xFFFF);
  146  1        uint16  rangeMaxExt = (uint16)( (MainSettingsExt.rangeLimits >> 16) & 0xFFFF);
  147  1      
  148  1        float currentDose = 0;
  149  1        float averageDose = 0;
  150  1        float counterRate = 0;
  151  1        uint16  uCntRate = 0;
  152  1        
  153  1        uint8 sliderMax = 2;  //–ø–∞—Ä–∞–º–µ—Ç—Ä –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –¥–≤–∏–∂–∫–∞
  154  1         
  155  1        memcpy((uint8*)sensorCnt,(uint8*)sensorCntCopy,sizeof(uint16) * SENSORS);
  156  1        
  157  1        /*
  158  1        –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ú–î
  159  1        */
  160  1        memcpy((uint8*)sensorCnt,(uint8*)tempSensorData_1,sizeof(uint16) * SENSORS);
  161  1        
  162  1      
  163  1        #ifdef RANGE3 //–¥–ª—è 38-—Ö —Å—á—ë—Ç—á–∏–∫–æ–≤ —Ä–∞—Å—á—ë—Ç –ø–æ –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º—É–ª–µ
  164  1          if(Process_GetExternalRange() == EXT_ON)
  165  1            currentDose = Process_CalculateLogDoseRate();
  166  1          else
  167  1            currentDose = Process_CalculateMaximumSumDoseRate();
  168  1          
  169  1            Debug_SetAlgorithmType(1);
  170  1        #else 
                  //–¥–ª—è 21-—Ö —Ä–∞—Å—á—ë—Ç –≤–µ–¥–µ—Ç—Å—è –ø–æ –¥–≤—É–º —Ñ–æ—Ä–º—É–ª–∞–º, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ
             -—Ç –ø–æ—Ä–æ–≥–∞
                  currentDose = Process_CalculateCurrentDoseRate();
                  Debug_SetAlgorithmType(0);
                  if(currentDose >= DOSERATE_LIMIT){
                    currentDose = Process_CalculateMaximumSumDoseRate();
                    Debug_SetAlgorithmType(1);
                  }
                  /*if(currentDose >= DOSERATE_LIMIT){
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 4   

                    currentDose = Process_CalculateMaximumSumDoseRate();
                    Debug_SetAlgorithmType(1);
                  }*/
                #endif
  183  1        
  184  1          //currentDose = Process_CalculateCurrentDoseRate();
  185  1          counterRate = Process_CalculateCountingRate();
  186  1        
  187  1        uCntRate = counterRate;
  188  1        
  189  1        Debug_SetCurrentDose(currentDose);
  190  1        Debug_SetCurrentSensorsData((uint8*)sensorCnt);
  191  1      
  192  1        if(Process_GetAutoModeStatus() == AUTO_ON)
  193  1        {
  194  2        
  195  2          //–æ—Ç—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  196  2          #ifdef RANGE3
  197  2            //–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º (4 –¥–∏–∞–ø–∞–∑–æ–Ω)
  198  2            if(Process_GetExternalRange())
  199  2            {
  200  3              //–ø–æ–Ω–∏–∂–∞–µ–º –¥–æ 3–µ–≥–æ
  201  3              if((counterRate <= rangeMinExt) && firstMeasureCounter >= FIRST_MEASURE_TIME){
  202  4                Process_Stop();
  203  4                Process_SetExternalRange(EXT_OFF);
  204  4                Process_Start();
  205  4              }
  206  3              if(counterRate >= rangeMaxExt){
  207  4                //—Ç—É—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ 20 —Å–µ–∫—É–Ω–¥ TODO
  208  4              }
  209  3            }
  210  2            else
  211  2            {
  212  3              //–µ—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –º–µ–Ω—å—à–µ –Ω–∏–∂–Ω–µ–≥–æ –ø—Ä–µ–¥–µ–ª–∞, —Ç–æ –æ—Å—Ç–∞–Ω–∞–≤
             -–ª–∏–≤–∞–µ–º —Ä–∞–±–æ—Ç—É –∏ –≤–∫–ª—é—á–∞–µ–º –Ω–∏–∂–Ω–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
  213  3              if((counterRate <= rangeMin) && firstMeasureCounter >= FIRST_MEASURE_TIME){
  214  4                
  215  4                Process_Stop();
  216  4                CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto2,3);
  217  4              }
  218  3              if(counterRate >= rangeMaxExt){
  219  4                Process_Stop();
  220  4                Process_SetExternalRange(EXT_ON);
  221  4                Process_Start();
  222  4              }
  223  3            }
  224  2          
  225  2      
  226  2          #endif
  227  2            
  228  2          #ifdef RANGE2
                    if((counterRate <= rangeMin) && firstMeasureCounter >= FIRST_MEASURE_TIME){
                      
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto1,3);
                    }
                    if(counterRate >= rangeMax){
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto3,3);
                    }
                  #endif
  239  2            
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 5   

  240  2          #ifdef RANGE1
                    if(counterRate >= rangeMax){
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto2,3);
                    }
                  #endif      
  246  2          }
  247  1        
  248  1        
  249  1        //–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫ –≤ 2—Å. —Ç–æ–ª—å–∫–æ –¥–ª—è 2 3 –∏ 4 –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤   
  250  1        #ifndef RANGE1
  251  1          if(sliderCounter<SLIDER_SIZE){
  252  2            sliderQuery[sliderCounter] = currentDose;
  253  2            sliderCounter++;
  254  2            
  255  2            Debug_SetQueryFull(0);
  256  2          }
  257  1          
  258  1          else{
  259  2            memcpy(&sliderQuery[0],&sliderQuery[1],sizeof(float) * (SLIDER_SIZE - 1));
  260  2            sliderQuery[SLIDER_SIZE - 1] = currentDose;
  261  2            
  262  2            Debug_SetQueryFull(1);
  263  2          }
  264  1          for(i = 0;i<SLIDER_SIZE;i++)
  265  1            averageDose += sliderQuery[i];
  266  1          
  267  1          averageDose = averageDose * 0.5f;
  268  1        #else
                  //–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥–≤–∏–¥–æ–∫ –¥–ª—è 1 –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                  //if(currentDose < SLIDER_30_MAX_LIM){
                  if(counterRate <= 3){
                    sliderMax = 30;
                    if(sliderMode == 2 || sliderMode == 3){   
                      sliderCounter = 30;
                      
                      if(sliderMode == 3)firstMeasureCounter = 0;
                        
                      //memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
                    }
              
                    if(sliderMode != 1)sliderCounter = 0;
                    sliderMode = 1;
                  }
                  //else if(currentDose >= SLIDER_10_MIN_LIM && currentDose < SLIDER_10_MAX_LIM){
                  else if(counterRate >= 2.5f && counterRate <= 12){
                    sliderMax = 10;
                    if(sliderMode == 3){
                        sliderCounter = 10;
                        //memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
                    }
                    if(sliderMode != 2)sliderCounter = 0;
                    sliderMode = 2;
                  }
                  //else if(currentDose >= SLIDER_2_MIN_LIM) {
                  else if(counterRate >= 10){
                    sliderMax = 2;
                    
                    if(sliderMode != 3)sliderCounter = 0;
                    sliderMode = 3;
                  }
                  
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 6   

                  if(sliderCounter<sliderMax){
                  sliderQuery[sliderCounter] = currentDose;
                  sliderCounter++;
                  }
                
                  else{
                    memcpy(&sliderQuery[0],&sliderQuery[1],sizeof(float) * (sliderMax - 1));
                    sliderQuery[sliderMax - 1] = currentDose;
                  }
                  
                  for(i = 0;i<sliderCounter;i++)
                    averageDose += sliderQuery[i];
                  
                  
                  sliderCounter ? averageDose = averageDose / sliderCounter : currentDose;
                #endif
  318  1        
  319  1        //—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–∞–∫–µ—Ç –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É
  320  1        /*
  321  1          4 —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ 8 –±–∞–π—Ç = 32 –±–∞–π—Ç–∞
  322  1        
  323  1          1 - –∑–∞–≥–æ–ª–æ–≤–æ–∫ 
  324  1          2 - 4 - –¥–∞–Ω–Ω—ã–µ —Å—á–µ—Ç—á–∏–∫–æ–≤
  325  1        */
  326  1        pSendPackage = (uint8*)malloc(sizeof(uint8) * 32);
  327  1        
  328  1        if(pSendPackage /*&& (firstMeasureCounter >= FIRST_MEASURE_TIME)*/){
  329  2          pSendPackage[0] = 0x40;
  330  2          pSendPackage[1] = 0xFF;
  331  2          
  332  2          memcpy(pSendPackage + 2,&uCntRate,sizeof(uint16));
  333  2          memcpy(pSendPackage + 4,&averageDose,sizeof(float));
  334  2          
  335  2          memcpy(pSendPackage + 8,sensorCnt,sizeof(uint16) * SENSORS);
  336  2          
  337  2          #ifdef RANGE3
  338  2            if(Process_GetExternalRange() == EXT_ON)
  339  2              CAN_SendDataPackage(TX_DATA_EXT,pSendPackage,32);
  340  2            else
  341  2              CAN_SendDataPackage(TX_DATA,pSendPackage,32);
  342  2          #else
                      CAN_SendDataPackage(TX_DATA,pSendPackage,32);
                  #endif
  345  2        }
  346  1        
  347  1        
  348  1        free(pSendPackage);
  349  1        /*
  350  1        Protocol_HeaderDataMsg(counterRate,averageDose);
  351  1        Protocol_CountersMsg(sensorCnt);
  352  1        Protocol_CountersMsg(sensorCnt + 4);
  353  1        Protocol_CountersMsg(sensorCnt + 8);
  354  1        */
  355  1        
  356  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);//–æ–±–Ω—É–ª—è–µ–º –º–∞—Å—Å–∏–≤ —Å—á—ë—Ç—á–∏–∫–æ–≤
  357  1      }
  358         
  359         //—Ñ–∏—è —Ä–∞—Å—á—ë—Ç–∞ –ú–î –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ß–¢–ó
  360         float Process_CalculateCurrentDoseRate()
  361         {
  362  1        
  363  1        
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 7   

  364  1        uint16  i = 0;
  365  1        float numerator = 0;
  366  1        float denominator = 0;
  367  1        float dose = 0;
  368  1        
  369  1        float leftPart = 0;
  370  1        float rightPart = 0;
  371  1        /*
  372  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  373  1          uint16  rangeMaxExt = (uint16)( (MainSettingsExt.rangeLimits >> 16) & 0xFFFF);
  374  1        //–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –≤ –º–∞—Å—Å–∏–≤–µ —Å—á—ë—Ç—á
             -–∏–∫–æ–≤
  375  1        #ifdef RANGE3 
  376  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  377  1        
  378  1          for(i = 0;i<SENSORS;i++)
  379  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  380  1        #endif
  381  1        
  382  1        #ifdef RANGE3 
  383  1          if(Process_GetExternalRange() == EXT_ON)
  384  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMaxExt;
  385  1          else
  386  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  387  1        #else
  388  1          for(i = 0;i<SENSORS;i++)
  389  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  390  1        #endif
  391  1        */
  392  1        
  393  1        //–ø–æ–ª—É—á–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å—á–µ—Ç–æ–≤ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –º—ë—Ä—Ç–≤–æ–≥–æ –≤—Ä–µ–º–µ–
             -Ω–∏
  394  1        float fDeadTime = MainSettings.mDeadTime;
  395  1        float fDeadTimeExt = MainSettingsExt.mDeadTime;
  396  1        
  397  1        float fCntLimit = 0,fCntLimitExt = 0;
  398  1        
  399  1          fCntLimit = 1.0 / fDeadTime - 1.0f;
  400  1          fCntLimitExt = 1.0 / fDeadTimeExt - 1.0f;
  401  1        
  402  1        #ifdef RANGE3 
  403  1      
  404  1          
  405  1          if(Process_GetExternalRange() == EXT_ON)
  406  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimit;
  407  1          else
  408  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimitExt;
  409  1        #else
                  for(i = 0;i<SENSORS;i++)
                    if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimit;
                #endif
  413  1        
  414  1          leftPart = 1.0f / (MainSettings.mSensivity * MainSettings.mEfficiency * 1);
  415  1            
  416  1            for(i = 0;i<SENSORS;i++)
  417  1            {
  418  2              numerator = sensorCnt[i] * MainSettings.correctionFactors[i];
  419  2              denominator = 1.0f - (sensorCnt[i] * MainSettings.mDeadTime);
  420  2              
  421  2              rightPart = rightPart + (numerator / denominator);
  422  2            }
  423  1        dose = leftPart * rightPart;
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 8   

  424  1        
  425  1        return dose;
  426  1      }
  427         
  428         //–ø–æ–¥—Å—á—ë—Ç –ú–î –ø–æ —Ñ–æ—Ä–º—É–ª–µ —Å—É–º–º—ã —Ç—Ä—ë—Ö –º–∞–∫—Å–∏–º—É–º–æ–≤
  429         float Process_CalculateMaximumSumDoseRate()
  430         {
  431  1        float fResult = 0;
  432  1        float sensorCorrectCnt[SENSORS];
  433  1        float fMax = 0;
  434  1        uint8 i = 0,j = 0;
  435  1        
  436  1        //–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –≤ –º–∞—Å—Å–∏–≤–µ —Å—á—ë—Ç—á
             -–∏–∫–æ–≤
  437  1        /*#ifdef RANGE3 
  438  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  439  1        
  440  1          for(i = 0;i<SENSORS;i++)
  441  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  442  1        #endif*/
  443  1        
  444  1        memset(sensorCorrectCnt,0,sizeof(float) * SENSORS);
  445  1        
  446  1          //–ø–æ–ª—É—á–∞–µ–º –æ—Ç–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—á–µ—Ç–∞
  447  1          for(i = 0;i<SENSORS;i++){
  448  2            sensorCorrectCnt[i] = (sensorCnt[i] * MainSettings.correctionFactors[i]) / (1.0f - (sensorCnt[i] * Main
             -Settings.mDeadTime));
  449  2          }
  450  1          //—Å–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
  451  1            for(i = 0;i<SENSORS - 1;i++){
  452  2              for(j = 0;j<SENSORS - i - 1;j++){
  453  3                if(sensorCorrectCnt[j] > sensorCorrectCnt[j+1]){
  454  4                  fMax = sensorCorrectCnt[j];
  455  4                  sensorCorrectCnt[j] = sensorCorrectCnt[j+1];
  456  4                  sensorCorrectCnt[j+1] = fMax;
  457  4                }
  458  3              }
  459  2            }
  460  1          Debug_SetSortSensorsData((uint8*)sensorCorrectCnt);
  461  1            
  462  1          fResult = (1.0f / (3.0f * MainSettings.mSensivity)) * (sensorCorrectCnt[11] + sensorCorrectCnt[10] + sen
             -sorCorrectCnt[9]);
  463  1            
  464  1          return fResult;
  465  1      }
  466         //–ø–æ–¥—Å—á—ë—Ç –ú–î –ø–æ –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª–µ
  467         float Process_CalculateLogDoseRate()
  468         {
  469  1        uint8 i = 0,j = 0;
  470  1        
  471  1        uint16 uMax = 0;
  472  1        uint16  sensorCorrectCnt[SENSORS];  //—Å–æ—Ä—Ç–∏—Ä—É–µ–º—ã–π –º–∞—Å—Å–∏–≤ —Å—á—ë—Ç—á–∏–∫–æ–≤
  473  1        
  474  1        float fCurCorrFactor = 0;
  475  1        float fSortCorrFactors[SENSORS];
  476  1        float fReturn = 0;
  477  1        float sensorsCorrectionSum = 0;
  478  1        
  479  1        float fPulseDuration = MainSettingsExt.pulseDuration / 1000000.0f;
  480  1        float fPulsePeriod = MainSettingsExt.pulsePwrPeriod / 1000000.0f;
  481  1        
  482  1        memcpy((uint8*)sensorCorrectCnt,(uint8*)sensorCnt,sizeof(uint16) * SENSORS);
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 9   

  483  1        memcpy((uint8*)fSortCorrFactors,(uint8*)MainSettingsExt.correctionFactors,sizeof(float) * SENSORS);
  484  1        
  485  1        //—Å–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
  486  1            for(i = 0;i<SENSORS - 1;i++){
  487  2              for(j = 0;j<SENSORS - i - 1;j++){
  488  3                if(sensorCorrectCnt[j] > sensorCorrectCnt[j+1]){
  489  4                  uMax = sensorCorrectCnt[j];
  490  4                  fCurCorrFactor = fSortCorrFactors[j];
  491  4                  
  492  4                  sensorCorrectCnt[j] = sensorCorrectCnt[j+1];  
  493  4                  fSortCorrFactors[j] = fSortCorrFactors[j+1];  //–º–∞—Å—Å–∏–≤ –ø–æ–ø—Ä–∞–≤–æ—á–Ω—ã—Ö —Å–æ—Ä—Ç–∏—Ä—É–µ–
             -º —Å–ª–µ–¥–æ–º –∑–∞ –º–∞—Å—Å–∏–≤–æ–º —Å—á–µ—Ç–æ–≤
  494  4                              
  495  4                  sensorCorrectCnt[j+1] = uMax;
  496  4                  fSortCorrFactors[j+1] = fCurCorrFactor;
  497  4                }
  498  3              }
  499  2            }
  500  1        
  501  1        
  502  1        
  503  1        //—Å—á–∏—Ç–∞–µ–º –ø–æ 3-–º –ø–æ—Å–ª–µ–¥–Ω–∏–º(–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ —Å—á–µ—Ç–∞)
  504  1          for(i = 9;i<SENSORS;i++){
  505  2            sensorsCorrectionSum +=( /*MainSettingsExt.correctionFactors[i]*/fSortCorrFactors[i] * (log(1.0 - senso
             -rCorrectCnt[i] *  fPulsePeriod)/ fPulseDuration));
  506  2          }
  507  1          
  508  1          fReturn = -1.0 / (MainSettingsExt.mSensivity * MainSettingsExt.mEfficiency) * sensorsCorrectionSum;
  509  1        
  510  1        return fReturn;
  511  1      }
  512         
  513         float Process_CalculateCountingRate()
  514         {
  515  1        float cntRate = 0;
  516  1        uint16  i = 0;
  517  1        
  518  1          for(i = 0;i<SENSORS;i++)
  519  1              cntRate += sensorCnt[i];
  520  1            cntRate = cntRate / (float)(MainSettings.mEfficiency /* SENSORS*/); //06.03.17 - –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤
             -–∫–∞ —Ñ–æ—Ä–º—É–ª—ã —Ä–∞—Å—Å—á—ë—Ç–∞ —Å—Ä–µ–¥–Ω–µ–π —Å–∫—Ä–æ—Ä–æ—Å—Ç–∏ —Å—á—ë—Ç–∞
  521  1        
  522  1        if(firstMeasureCounter < FIRST_MEASURE_TIME)
  523  1          firstMeasureCounter++;
  524  1        
  525  1        return cntRate;
  526  1      }
  527         
  528         void Process_Start()
  529         {
  530  1        //–ø–µ—Ä–µ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –®–ò–ú –¥–ª—è 3 –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  531  1        #ifdef RANGE3
  532  1          if(Process_GetExternalRange())PWM2();
  533  1          else PWM1();
  534  1        #endif
  535  1        
  536  1        Process_Stop();
  537  1        
  538  1        sliderCounter = 0;
  539  1        firstMeasureCounter = 0;
  540  1        
  541  1        memset(sensorCnt,0,sizeof(uint16) * SENSORS);
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 12:55:48 PAGE 10  

  542  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);
  543  1        
  544  1        memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
  545  1        /*
  546  1        –ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–ø—É—Å–∫–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π
  547  1        
  548  1          - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –∑–∞–¥–∞–Ω–Ω—ã—Ö –¥–∏–∞–ø–∞–∑–æ–Ω. –ï—Å–ª–∏ —ç—Ç–æ 1,2,3 - —Ç–æ –∑–∞
             -–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
  549  1          -
  550  1        */
  551  1        
  552  1        
  553  1        T0 = 0xFFFF;
  554  1        T7R = 1;
  555  1        T8R = 1;
  556  1        
  557  1        HV_STATE = 1;
  558  1        //TO_DO –æ–∂–∏–¥–∞–µ–º –Ω–∞—Ä–∞—Å—Ç–∞–Ω–∏–µ –≤—ã—Å–æ–∫–æ–≥–æ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è
  559  1        
  560  1        
  561  1        T0R = 1;
  562  1        
  563  1      
  564  1      }
  565         
  566         void Process_Stop()
  567         {
  568  1        //PWM OFF
  569  1        T7R = 0;
  570  1        T8R = 0;
  571  1        //MAINTIMER OFF
  572  1        T0R = 0;
  573  1        //H-Bridge off
  574  1          KEY11_L = 0; KEY11_H = 0;
  575  1          KEY12_L = 0; KEY12_H = 0;
  576  1        HV_STATE = 0;
  577  1        
  578  1        
  579  1      }


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        2710     --------
  NEAR-CONST SIZE  =          33     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          63     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          18     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
