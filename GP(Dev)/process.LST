C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 1   


C166 COMPILER V7.53.0.0, COMPILATION OF MODULE PROCESS
OBJECT MODULE PLACED IN .\firmwares\process.obj
COMPILER INVOKED BY: C:\Keil\C166\BIN\C166.EXE process.c BROWSE MOD167 DEBUG TABS(2) OBJECT(.\firmwares\process.obj) 

 stmt lvl     source

    1         #include "process.h"
    2         #include "protocol.h"
    3         #include "settings.h"
    4         #include "can.h"
    5         #include "debug.h"
    6         
    7         uint8   firstMeasureCounter = 0;
    8         uint8   sliderCounter = 0;
    9         uint8   sliderMode = 0;
   10         uint16  sensorCnt[SENSORS];
   11         uint16  sensorCntCopy[SENSORS];
   12         
   13         float   sliderQuery[SLIDER_SIZE];
   14         
   15         eAutoModeState  autoMode;
   16         eExternalRange  extRange;
   17         
   18         void  Process_SetAutoMode(eAutoModeState State){autoMode = State;}
   19         uint8 Process_GetAutoModeStatus(){return autoMode;}
   20         void  Process_SetExternalRange(eExternalRange ExtRange){extRange = ExtRange;}
   21         uint8 Process_GetExternalRange(){return extRange;}
   22         
   23         void  Process_Initializetion(void)
   24         {
   25  1        CC8IC = 0x0070;
   26  1        CC9IC = 0x0071;
   27  1        CC10IC = 0x0072;
   28  1        CC11IC = 0x0073;
   29  1        CC12IC = 0x0074;
   30  1        CC13IC = 0x0075;
   31  1        CC14IC = 0x0076;
   32  1        CC15IC = 0x0077;
   33  1        
   34  1        T2IC = 0x0078;
   35  1        T3IC = 0x0079;
   36  1        T4IC = 0x007A;
   37  1        T5IC = 0x007B;
   38  1        memset(sensorCnt,0,sizeof(uint16) * SENSORS);
   39  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);
   40  1        
   41  1        memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
   42  1        
   43  1        autoMode = AUTO_OFF;
   44  1        extRange = EXT_OFF;
   45  1        
   46  1        sliderMode = 0;
   47  1      }
   48         
   49         /*
   50           –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–º–ø—É–ª—å—Å–∞ —Å—á—ë—Ç—á–∏–∫–∞
   51           1. –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä—É–µ–º —Å—á—ë—Ç—á–∏–∫ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–Ω–∞–ª–∞
   52           2. –°–Ω–∏–º–∞–µ–º –ø–∏—Ç–∞–Ω–∏–µ  –Ω–∞ —Å—á—ë—Ç—á–∏–∫–∞—Ö –Ω–∞ 100us
   53         */
   54         
   55         void Process_EXIN1()  interrupt CC8IC_VEC
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 2   

   56         {
   57  1        
   58  1        T7 = 0xFFFF;
   59  1        sensorCntCopy[0]++;
   60  1      }
   61         void Process_EXIN2()  interrupt CC9IC_VEC
   62         {
   63  1        T7 = 0xFFFF;
   64  1        sensorCntCopy[1]++;
   65  1        
   66  1      }
   67         void Process_EXIN3()  interrupt CC10IC_VEC
   68         {
   69  1        T7 = 0xFFFF;
   70  1        sensorCntCopy[2]++;
   71  1      }
   72         void Process_EXIN4()  interrupt CC11IC_VEC
   73         {
   74  1        T7 = 0xFFFF;
   75  1        sensorCntCopy[3]++;
   76  1      }
   77         void Process_EXIN5()  interrupt CC12IC_VEC
   78         {
   79  1        T7 = 0xFFFF;
   80  1        sensorCntCopy[4]++;
   81  1      }
   82         void Process_EXIN6()  interrupt CC13IC_VEC
   83         {
   84  1        T7 = 0xFFFF;
   85  1        sensorCntCopy[5]++;
   86  1      }
   87         void Process_EXIN7()  interrupt CC14IC_VEC
   88         {
   89  1        T8 = 0xFFFF;
   90  1        sensorCntCopy[6]++;
   91  1      }
   92         void Process_EXIN8()  interrupt CC15IC_VEC
   93         {
   94  1        T8 = 0xFFFF;
   95  1        sensorCntCopy[7]++;
   96  1      }
   97         void Process_EXIN9()  interrupt T5IC_VEC
   98         {
   99  1        T8 = 0xFFFF;
  100  1        
  101  1        sensorCntCopy[8]++;
  102  1      }
  103         void Process_EXIN10() interrupt T4IC_VEC
  104         {
  105  1        T8 = 0xFFFF;
  106  1        
  107  1        sensorCntCopy[9]++;
  108  1      }
  109         void Process_EXIN11() interrupt T3IC_VEC
  110         {
  111  1        T8 = 0xFFFF;
  112  1        
  113  1        sensorCntCopy[10]++;
  114  1      }
  115         void Process_EXIN12() interrupt T2IC_VEC
  116         {
  117  1        T8 = 0xFFFF;
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 3   

  118  1        
  119  1        sensorCntCopy[11]++;
  120  1      }
  121         
  122         void  Process_MainProc()  interrupt T0IC_VEC
  123         {
  124  1         uint8  *pSendPackage;
  125  1        
  126  1         uint8  mStartRangeAuto1[]  = {0x01,0x01,0x01};
  127  1         uint8  mStartRangeAuto2[]  = {0x02,0x01,0x01};
  128  1         uint8  mStartRangeAuto3[]  = {0x03,0x01,0x01};
  129  1      /*  float currentDose = 0;
  130  1        
  131  1        currentDose = Process_CalculateDoseRate();
  132  1        
  133  1        
  134  1        Protocol_HeaderDataMsg();
  135  1        Protocol_CounterMsg(sensorCnt);
  136  1        Protocol_DoseRateMsg(currentDose);
  137  1        */
  138  1        //Protocol_ResponseDataPackaje(E_NEWDATA_RESPONSE);
  139  1        uint8 i = 0,j = 0;
  140  1        
  141  1        uint16  rangeMin = (uint16)(MainSettings.rangeLimits & 0xFFFF);
  142  1        uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  143  1        uint16  rangeMinExt = (uint16)(MainSettingsExt.rangeLimits & 0xFFFF);
  144  1        uint16  rangeMaxExt = (uint16)( (MainSettingsExt.rangeLimits >> 16) & 0xFFFF);
  145  1      
  146  1        float currentDose = 0;
  147  1        float averageDose = 0;
  148  1        float counterRate = 0;
  149  1        uint16  uCntRate = 0;
  150  1        
  151  1        uint8 sliderMax = 2;  //–ø–∞—Ä–∞–º–µ—Ç—Ä –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –¥–≤–∏–∂–∫–∞
  152  1         
  153  1        memcpy((uint8*)sensorCnt,(uint8*)sensorCntCopy,sizeof(uint16) * SENSORS);
  154  1         
  155  1        #ifdef RANGE3 //–¥–ª—è 38-—Ö —Å—á—ë—Ç—á–∏–∫–æ–≤ —Ä–∞—Å—á—ë—Ç –ø–æ –¥—Ä—É–≥–æ–π —Ñ–æ—Ä–º—É–ª–µ
  156  1          if(Process_GetExternalRange() == EXT_ON)
  157  1            currentDose = Process_CalculateLogDoseRate();
  158  1          else
  159  1            currentDose = Process_CalculateMaximumSumDoseRate();
  160  1          
  161  1            Debug_SetAlgorithmType(1);
  162  1        #else 
                  //–¥–ª—è 21-—Ö —Ä–∞—Å—á—ë—Ç –≤–µ–¥–µ—Ç—Å—è –ø–æ –¥–≤—É–º —Ñ–æ—Ä–º—É–ª–∞–º, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ
             -—Ç –ø–æ—Ä–æ–≥–∞
                  currentDose = Process_CalculateCurrentDoseRate();
                  Debug_SetAlgorithmType(0);
                  if(currentDose >= DOSERATE_LIMIT){
                    currentDose = Process_CalculateMaximumSumDoseRate();
                    Debug_SetAlgorithmType(1);
                  }
                  /*if(currentDose >= DOSERATE_LIMIT){
                    currentDose = Process_CalculateMaximumSumDoseRate();
                    Debug_SetAlgorithmType(1);
                  }*/
                #endif
  175  1        
  176  1          //currentDose = Process_CalculateCurrentDoseRate();
  177  1          counterRate = Process_CalculateCountingRate();
  178  1        
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 4   

  179  1        uCntRate = counterRate;
  180  1        
  181  1        Debug_SetCurrentDose(currentDose);
  182  1        Debug_SetCurrentSensorsData((uint8*)sensorCnt);
  183  1      
  184  1        if(Process_GetAutoModeStatus() == AUTO_ON)
  185  1        {
  186  2        
  187  2          //–æ—Ç—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  188  2          #ifdef RANGE3
  189  2            //–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º (4 –¥–∏–∞–ø–∞–∑–æ–Ω)
  190  2            if(Process_GetExternalRange())
  191  2            {
  192  3              //–ø–æ–Ω–∏–∂–∞–µ–º –¥–æ 3–µ–≥–æ
  193  3              if((counterRate <= rangeMinExt) && firstMeasureCounter >= FIRST_MEASURE_TIME){
  194  4                Process_Stop();
  195  4                Process_SetExternalRange(EXT_OFF);
  196  4                Process_Start();
  197  4              }
  198  3              if(counterRate >= rangeMaxExt){
  199  4                //—Ç—É—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ 20 —Å–µ–∫—É–Ω–¥ TODO
  200  4              }
  201  3            }
  202  2            else
  203  2            {
  204  3              //–µ—Å–ª–∏ —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –º–µ–Ω—å—à–µ –Ω–∏–∂–Ω–µ–≥–æ –ø—Ä–µ–¥–µ–ª–∞, —Ç–æ –æ—Å—Ç–∞–Ω–∞–≤
             -–ª–∏–≤–∞–µ–º —Ä–∞–±–æ—Ç—É –∏ –≤–∫–ª—é—á–∞–µ–º –Ω–∏–∂–Ω–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
  205  3              if((counterRate <= rangeMin) && firstMeasureCounter >= FIRST_MEASURE_TIME){
  206  4                
  207  4                Process_Stop();
  208  4                CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto2,3);
  209  4              }
  210  3              if(counterRate >= rangeMaxExt){
  211  4                Process_Stop();
  212  4                Process_SetExternalRange(EXT_ON);
  213  4                Process_Start();
  214  4              }
  215  3            }
  216  2          
  217  2      
  218  2          #endif
  219  2            
  220  2          #ifdef RANGE2
                    if((counterRate <= rangeMin) && firstMeasureCounter >= FIRST_MEASURE_TIME){
                      
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto1,3);
                    }
                    if(counterRate >= rangeMax){
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto3,3);
                    }
                  #endif
  231  2            
  232  2          #ifdef RANGE1
                    if(counterRate >= rangeMax){
                      Process_Stop();
                      CAN_SendMessage(TX_CHANGE_RANGE,mStartRangeAuto2,3);
                    }
                  #endif      
  238  2          }
  239  1        
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 5   

  240  1        
  241  1        //–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫ –≤ 2—Å. —Ç–æ–ª—å–∫–æ –¥–ª—è 2 3 –∏ 4 –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤   
  242  1        #ifndef RANGE1
  243  1          if(sliderCounter<SLIDER_SIZE){
  244  2            sliderQuery[sliderCounter] = currentDose;
  245  2            sliderCounter++;
  246  2            
  247  2            Debug_SetQueryFull(0);
  248  2          }
  249  1          
  250  1          else{
  251  2            memcpy(&sliderQuery[0],&sliderQuery[1],sizeof(float) * (SLIDER_SIZE - 1));
  252  2            sliderQuery[SLIDER_SIZE - 1] = currentDose;
  253  2            
  254  2            Debug_SetQueryFull(1);
  255  2          }
  256  1          for(i = 0;i<SLIDER_SIZE;i++)
  257  1            averageDose += sliderQuery[i];
  258  1          
  259  1          averageDose = averageDose * 0.5f;
  260  1        #else
                  //–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥–≤–∏–¥–æ–∫ –¥–ª—è 1 –¥–∏–∞–ø–∞–∑–æ–Ω–∞
                  //if(currentDose < SLIDER_30_MAX_LIM){
                  if(counterRate <= 3){
                    sliderMax = 30;
                    if(sliderMode == 2 || sliderMode == 3){   
                      sliderCounter = 30;
                      
                      if(sliderMode == 3)firstMeasureCounter = 0;
                        
                      //memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
                    }
              
                    if(sliderMode != 1)sliderCounter = 0;
                    sliderMode = 1;
                  }
                  //else if(currentDose >= SLIDER_10_MIN_LIM && currentDose < SLIDER_10_MAX_LIM){
                  else if(counterRate >= 2.5f && counterRate <= 12){
                    sliderMax = 10;
                    if(sliderMode == 3){
                        sliderCounter = 10;
                        //memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
                    }
                    if(sliderMode != 2)sliderCounter = 0;
                    sliderMode = 2;
                  }
                  //else if(currentDose >= SLIDER_2_MIN_LIM) {
                  else if(counterRate >= 10){
                    sliderMax = 2;
                    
                    if(sliderMode != 3)sliderCounter = 0;
                    sliderMode = 3;
                  }
                  
                  if(sliderCounter<sliderMax){
                  sliderQuery[sliderCounter] = currentDose;
                  sliderCounter++;
                  }
                
                  else{
                    memcpy(&sliderQuery[0],&sliderQuery[1],sizeof(float) * (sliderMax - 1));
                    sliderQuery[sliderMax - 1] = currentDose;
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 6   

                  }
                  
                  for(i = 0;i<sliderCounter;i++)
                    averageDose += sliderQuery[i];
                  
                  
                  sliderCounter ? averageDose = averageDose / sliderCounter : currentDose;
                #endif
  310  1        
  311  1        //—Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–∞–∫–µ—Ç –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É
  312  1        /*
  313  1          4 —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ 8 –±–∞–π—Ç = 32 –±–∞–π—Ç–∞
  314  1        
  315  1          1 - –∑–∞–≥–æ–ª–æ–≤–æ–∫ 
  316  1          2 - 4 - –¥–∞–Ω–Ω—ã–µ —Å—á–µ—Ç—á–∏–∫–æ–≤
  317  1        */
  318  1        pSendPackage = (uint8*)malloc(sizeof(uint8) * 32);
  319  1        
  320  1        if(pSendPackage /*&& (firstMeasureCounter >= FIRST_MEASURE_TIME)*/){
  321  2          pSendPackage[0] = 0x40;
  322  2          pSendPackage[1] = 0xFF;
  323  2          
  324  2          memcpy(pSendPackage + 2,&uCntRate,sizeof(uint16));
  325  2          memcpy(pSendPackage + 4,&averageDose,sizeof(float));
  326  2          
  327  2          memcpy(pSendPackage + 8,sensorCnt,sizeof(uint16) * SENSORS);
  328  2          
  329  2          #ifdef RANGE3
  330  2            if(Process_GetExternalRange() == EXT_ON)
  331  2              CAN_SendDataPackage(TX_DATA_EXT,pSendPackage,32);
  332  2            else
  333  2              CAN_SendDataPackage(TX_DATA,pSendPackage,32);
  334  2          #else
                      CAN_SendDataPackage(TX_DATA,pSendPackage,32);
                  #endif
  337  2        }
  338  1        
  339  1        
  340  1        free(pSendPackage);
  341  1        /*
  342  1        Protocol_HeaderDataMsg(counterRate,averageDose);
  343  1        Protocol_CountersMsg(sensorCnt);
  344  1        Protocol_CountersMsg(sensorCnt + 4);
  345  1        Protocol_CountersMsg(sensorCnt + 8);
  346  1        */
  347  1        
  348  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);//–æ–±–Ω—É–ª—è–µ–º –º–∞—Å—Å–∏–≤ —Å—á—ë—Ç—á–∏–∫–æ–≤
  349  1      }
  350         
  351         //—Ñ–∏—è —Ä–∞—Å—á—ë—Ç–∞ –ú–î –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ß–¢–ó
  352         float Process_CalculateCurrentDoseRate()
  353         {
  354  1        
  355  1        
  356  1        uint16  i = 0;
  357  1        float numerator = 0;
  358  1        float denominator = 0;
  359  1        float dose = 0;
  360  1        
  361  1        float leftPart = 0;
  362  1        float rightPart = 0;
  363  1        /*
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 7   

  364  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  365  1          uint16  rangeMaxExt = (uint16)( (MainSettingsExt.rangeLimits >> 16) & 0xFFFF);
  366  1        //–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –≤ –º–∞—Å—Å–∏–≤–µ —Å—á—ë—Ç—á
             -–∏–∫–æ–≤
  367  1        #ifdef RANGE3 
  368  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  369  1        
  370  1          for(i = 0;i<SENSORS;i++)
  371  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  372  1        #endif
  373  1        
  374  1        #ifdef RANGE3 
  375  1          if(Process_GetExternalRange() == EXT_ON)
  376  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMaxExt;
  377  1          else
  378  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  379  1        #else
  380  1          for(i = 0;i<SENSORS;i++)
  381  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  382  1        #endif
  383  1        */
  384  1        
  385  1        //–ø–æ–ª—É—á–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Å—á–µ—Ç–æ–≤ –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –º—ë—Ä—Ç–≤–æ–≥–æ –≤—Ä–µ–º–µ–
             -Ω–∏
  386  1        float fDeadTime = MainSettings.mDeadTime;
  387  1        float fDeadTimeExt = MainSettingsExt.mDeadTime;
  388  1        
  389  1        float fCntLimit = 0,fCntLimitExt = 0;
  390  1        
  391  1          fCntLimit = 1.0 / fDeadTime - 1.0f;
  392  1          fCntLimitExt = 1.0 / fDeadTimeExt - 1.0f;
  393  1        
  394  1        #ifdef RANGE3 
  395  1      
  396  1          
  397  1          if(Process_GetExternalRange() == EXT_ON)
  398  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimit;
  399  1          else
  400  1            for(i = 0;i<SENSORS;i++)if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimitExt;
  401  1        #else
                  for(i = 0;i<SENSORS;i++)
                    if(sensorCnt[i] > fCntLimit)sensorCnt[i] = fCntLimit;
                #endif
  405  1        
  406  1          leftPart = 1.0f / (MainSettings.mSensivity * MainSettings.mEfficiency * 1);
  407  1            
  408  1            for(i = 0;i<SENSORS;i++)
  409  1            {
  410  2              numerator = sensorCnt[i] * MainSettings.correctionFactors[i];
  411  2              denominator = 1.0f - (sensorCnt[i] * MainSettings.mDeadTime);
  412  2              
  413  2              rightPart = rightPart + (numerator / denominator);
  414  2            }
  415  1        dose = leftPart * rightPart;
  416  1        
  417  1        return dose;
  418  1      }
  419         
  420         //–ø–æ–¥—Å—á—ë—Ç –ú–î –ø–æ —Ñ–æ—Ä–º—É–ª–µ —Å—É–º–º—ã —Ç—Ä—ë—Ö –º–∞–∫—Å–∏–º—É–º–æ–≤
  421         float Process_CalculateMaximumSumDoseRate()
  422         {
  423  1        float fResult = 0;
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 8   

  424  1        float sensorCorrectCnt[SENSORS];
  425  1        float fMax = 0;
  426  1        uint8 i = 0,j = 0;
  427  1        
  428  1        //–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å —Å—á—ë—Ç–∞ –≤ –º–∞—Å—Å–∏–≤–µ —Å—á—ë—Ç—á
             -–∏–∫–æ–≤
  429  1        /*#ifdef RANGE3 
  430  1          uint16  rangeMax = (uint16)( (MainSettings.rangeLimits >> 16) & 0xFFFF);
  431  1        
  432  1          for(i = 0;i<SENSORS;i++)
  433  1            if(sensorCnt[i] > rangeMax)sensorCnt[i] = rangeMax;
  434  1        #endif*/
  435  1        
  436  1        memset(sensorCorrectCnt,0,sizeof(float) * SENSORS);
  437  1        
  438  1          //–ø–æ–ª—É—á–∞–µ–º –æ—Ç–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—á–µ—Ç–∞
  439  1          for(i = 0;i<SENSORS;i++){
  440  2            sensorCorrectCnt[i] = (sensorCnt[i] * MainSettings.correctionFactors[i]) / (1.0f - (sensorCnt[i] * Main
             -Settings.mDeadTime));
  441  2          }
  442  1          //—Å–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
  443  1            for(i = 0;i<SENSORS - 1;i++){
  444  2              for(j = 0;j<SENSORS - i - 1;j++){
  445  3                if(sensorCorrectCnt[j] > sensorCorrectCnt[j+1]){
  446  4                  fMax = sensorCorrectCnt[j];
  447  4                  sensorCorrectCnt[j] = sensorCorrectCnt[j+1];
  448  4                  sensorCorrectCnt[j+1] = fMax;
  449  4                }
  450  3              }
  451  2            }
  452  1          Debug_SetSortSensorsData((uint8*)sensorCorrectCnt);
  453  1            
  454  1          fResult = (1.0f / (3.0f * MainSettings.mSensivity)) * (sensorCorrectCnt[11] + sensorCorrectCnt[10] + sen
             -sorCorrectCnt[9]);
  455  1            
  456  1          return fResult;
  457  1      }
  458         //–ø–æ–¥—Å—á—ë—Ç –ú–î –ø–æ –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—É–ª–µ
  459         float Process_CalculateLogDoseRate()
  460         {
  461  1        float fReturn = 0;
  462  1        float sensorsCorrectionSum = 0;
  463  1        
  464  1        uint8 i = 0;
  465  1        
  466  1          for(i = 0;i<SENSORS;i++){
  467  2            sensorsCorrectionSum +=(-MainSettingsExt.correctionFactors[i] * (log(1.0 - sensorCnt[i] * MainSettingsE
             -xt.pulsePwrPeriod)/MainSettingsExt.pulseDuration));
  468  2          }
  469  1          
  470  1          fReturn = 1.0 / (MainSettingsExt.mSensivity * MainSettingsExt.mEfficiency) * sensorsCorrectionSum;
  471  1        
  472  1        return fReturn;
  473  1      }
  474         
  475         float Process_CalculateCountingRate()
  476         {
  477  1        float cntRate = 0;
  478  1        uint16  i = 0;
  479  1        
  480  1          for(i = 0;i<SENSORS;i++)
  481  1              cntRate += sensorCnt[i];
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 9   

  482  1            cntRate = cntRate / (float)(MainSettings.mEfficiency /* SENSORS*/); //06.03.17 - –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤
             -–∫–∞ —Ñ–æ—Ä–º—É–ª—ã —Ä–∞—Å—Å—á—ë—Ç–∞ —Å—Ä–µ–¥–Ω–µ–π —Å–∫—Ä–æ—Ä–æ—Å—Ç–∏ —Å—á—ë—Ç–∞
  483  1        
  484  1        if(firstMeasureCounter < FIRST_MEASURE_TIME)
  485  1          firstMeasureCounter++;
  486  1        
  487  1        return cntRate;
  488  1      }
  489         
  490         void Process_Start()
  491         {
  492  1        //–ø–µ—Ä–µ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –®–ò–ú –¥–ª—è 3 –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  493  1        #ifdef RANGE3
  494  1          if(Process_GetExternalRange())PWM2();
  495  1          else PWM1();
  496  1        #endif
  497  1        
  498  1        Process_Stop();
  499  1        
  500  1        sliderCounter = 0;
  501  1        firstMeasureCounter = 0;
  502  1        
  503  1        memset(sensorCnt,0,sizeof(uint16) * SENSORS);
  504  1        memset(sensorCntCopy,0,sizeof(uint16) * SENSORS);
  505  1        
  506  1        memset(sliderQuery,0,sizeof(float) * SLIDER_SIZE);
  507  1        /*
  508  1        –ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–ø—É—Å–∫–∞ –∏–∑–º–µ—Ä–µ–Ω–∏–π
  509  1        
  510  1          - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –∑–∞–¥–∞–Ω–Ω—ã—Ö –¥–∏–∞–ø–∞–∑–æ–Ω. –ï—Å–ª–∏ —ç—Ç–æ 1,2,3 - —Ç–æ –∑–∞
             -–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ—Ä–µ–Ω–∏–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
  511  1          -
  512  1        */
  513  1        
  514  1        
  515  1        T0 = 0xFFFF;
  516  1        T7R = 1;
  517  1        T8R = 1;
  518  1        
  519  1        HV_STATE = 1;
  520  1        //TO_DO –æ–∂–∏–¥–∞–µ–º –Ω–∞—Ä–∞—Å—Ç–∞–Ω–∏–µ –≤—ã—Å–æ–∫–æ–≥–æ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è
  521  1        
  522  1        
  523  1        T0R = 1;
  524  1        
  525  1      
  526  1      }
  527         
  528         void Process_Stop()
  529         {
  530  1        //PWM OFF
  531  1        T7R = 0;
  532  1        T8R = 0;
  533  1        //MAINTIMER OFF
  534  1        T0R = 0;
  535  1        //H-Bridge off
  536  1          KEY11_L = 0; KEY11_H = 0;
  537  1          KEY12_L = 0; KEY12_H = 0;
  538  1        HV_STATE = 0;
  539  1        
  540  1        
  541  1      }
C166 COMPILER V7.53.0.0, PROCESS                                                           03/26/2018 10:37:42 PAGE 10  



MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        2432     --------
  NEAR-CONST SIZE  =           9     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          63     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          18     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
